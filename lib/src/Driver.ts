import { toFixed } from './utils'
import type { Property } from './Property'
import type { TheSuperSonicPlugin } from './TheSupersonicPlugin'
import { Element } from './Element'

import type { BorderConstructor, Constructor, HelperConstructor, Hooks, Init, Render } from './Driver.types'

/**
 * The main purpose of Driver is to calculate current progress from 0 to 1 depending on current scroll
 */
export class Driver {
  id: string
  /** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 3 numbers after decimal point precision */
  progress = 0
  /** Only active drivers are rendered. Driver becomes active when it's HTML elements become visible */
  active = false
  /** Initial distance is used to implement all of the transformations after page reload with scroll */
  initialDistanceToScroll = 0
  /** You can store your custom data here to use between hooks */
  data = {}
  /** Start is linked to [data-supersonic-type="start"] HTML element */
  start: Border
  /** End is linked to [data-supersonic-type="end"] HTML element */
  end: Border
  /** Properties which are animated by this Driver. Properties are added during creating Property instance */
  properties: Set<Property> = new Set()
  /** Elements which are animated by this Driver. Elements are added during creating Element instance */
  elements: Set<Element> = new Set()
  /** Helper is an HTML element, which is created dynamically and has a height of distance between driver.end and driver.start. IntersectionObserver uses helper to check if driver is active or not. */
  helper: Helper

  plugin: TheSuperSonicPlugin
  hooks: Hooks

  constructor({ id, plugin, start, end, hooks = {} }: Constructor) {
    this.id = id
    this.plugin = plugin
    this.hooks = hooks

    if (this.hooks.onBeforeInit)
      this.hooks.onBeforeInit(this)

    // Initializing borders
    this.start = new Border({
      domElement: start,
      plugin: this.plugin,
      type: 'start',
      driver: this,
    })
    this.end = new Border({
      domElement: end,
      plugin: this.plugin,
      type: 'end',
      driver: this,
    })

    this.helper = new Helper({ driver: this, plugin })

    Driver.instances.set(id, this)

    if (this.hooks.onAfterInit)
      this.hooks.onAfterInit(this)
  }

  /** Driver calculates its progress and then renders all of it's properties with progress value. Also, driver ensures that only active elements will be rendered */
  render() {
    const oldProgress = this.progress
    this.progress = this.calculateProgress()

    if (this.hooks.onBeforeRender)
      this.hooks.onBeforeRender(this)

    if (oldProgress !== this.progress || !this.plugin.renderedInitially) {
      console.groupCollapsed(
					`Driver "${this.id}" starts rendering, progress is ${this.progress}, scroll is ${this.plugin.scroll}`,
      )

      for (const property of this.properties)
        property.render()

      for (const element of this.elements)
        Element.activeInstances.add(element)

      if (this.hooks.onAfterRender)
        this.hooks.onAfterRender(this)

      console.log(`Driver "${this.id}" finished rendering`)
      console.groupEnd()
    }
  }

  /** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
  calculateProgress(): number {
    let progress = (this.plugin.scroll - this.start.top) / (this.end.top - this.start.top)
    if (progress < 0)
      progress = 0
    else if (progress > 1)
      progress = 1
    else progress = toFixed(progress, 4)

    return progress
  }

  /** Recalculates DOM elements top offset */
  updateLimits() {
    this.start.updateLimits()
    this.end.updateLimits()
    this.helper.updateLimits()

    for (const property of this.properties)
      property.updateLimits()

    for (const element of this.elements)
      element.updateLimits(this)

    if (this.hooks.onUpdateLimits)
      this.hooks.onUpdateLimits(this)
  }

  /** Activates driver when it becomes visible on the screen */
  activate() {
    this.active = true
    Driver.activeInstances.add(this)

    if (this.hooks.onActivation)
      this.hooks.onActivation(this)

    console.log(`Driver "${this.id}" activated`)
  }

  /** Deactivates driver when it's progress becomes 0 or 1' */
  deactivate() {
    this.active = false
    Driver.activeInstances.delete(this)

    if (this.hooks.onDeactivation)
      this.hooks.onDeactivation(this)

    console.log(`Driver "${this.id}" deactivated`)
  }

  //
  //
  // static properties
  /** All Driver instances */
  static instances: Map<string, Driver> = new Map()
  /** All active Driver instances */
  static activeInstances: Set<Driver> = new Set()

  //
  //
  // static methods
  /** Initialize Driver instances */
  static init({ drivers, plugin }: Init) {
    for (const id in drivers) {
      new Driver({
        id,
        hooks: drivers[id].hooks,
        plugin,
        start: drivers[id].start,
        end: drivers[id].end,
      })
    }
  }

  /** Unitialize Driver instances */
  static uninit() {
    for (const driver of Driver.instances.values())
      driver.helper.uninit()

    Driver.instances.clear()
  }

  /** Render all of the Driver instances (active or not, depending on argument "useActiveDrivers") */
  static render({ useActiveDrivers, plugin }: Render) {
    const drivers = useActiveDrivers ? Driver.activeInstances.values() : Driver.instances.values()

    for (const driver of drivers) {
      if (!plugin.renderedInitially)
        driver.initialDistanceToScroll = driver.end.top - plugin.scroll
      driver.render()
    }
  }

  /** Call "updateLimits()" on each Driver instance, even deactivated */
  static updateLimits() {
    for (const driver of Driver.instances.values())
      driver.updateLimits()
  }
}

/** One instance for each [data-supersonic-type="start"] and  [data-supersonic-type="end"] */
class Border {
  /** Associated DOM element */
  domElement: HTMLElement
  /** Top means amount of scroll needed to border activate or deactivate driver */
  top: number = 0

  plugin: TheSuperSonicPlugin

  constructor({ domElement, plugin, type, driver }: BorderConstructor) {
    if (!domElement)
      throw new Error(`Can't find "${type}" HTMLElement for driver "${driver.id}"`)

    this.domElement = domElement
    this.plugin = plugin
  }

  /** Recalculates top offset */
  updateLimits() {
    this.top = ~~this.domElement.getBoundingClientRect().top + this.plugin.scroll
  }
}

/** A helper HTML element, which connects to Border instances and starts being tracked by IntersectionObserver */
class Helper {
  /** DOM element which is dynamically generated by plugin */
  domElement: HTMLElement
  /** Link to corresponding driver */
  driver: Driver

  plugin: TheSuperSonicPlugin

  constructor({ driver, plugin }: HelperConstructor) {
    this.driver = driver
    this.plugin = plugin

    this.domElement = document.createElement('i')
    this.domElement.style.position = 'absolute'
    this.domElement.style.left = '0'
    this.domElement.style.width = '1px'

    this.domElement.setAttribute('data-supersonic-driver', driver.id)
    this.domElement.setAttribute('data-supersonic-type', 'helper')
    this.domElement.classList.add('supersonic-helper')

    document.body.appendChild(this.domElement)

    /*
		this.domElement.style.left =
				Array.from(document.querySelectorAll("[data-supersonic-type='helper']")).indexOf(this.domElement) * 5 +
				"px"
		*/
  }

  /** Recalculates position of helper */
  updateLimits() {
    const top = this.driver.start.top + this.plugin.screenHeight
    const end = this.driver.end.top + this.plugin.screenHeight

    this.domElement.style.setProperty('top', `${top}px`)
    this.domElement.style.setProperty('height', `${end - top}px`)
  }

  /** Deletes helper DOM element */
  uninit() {
    this.domElement.remove()
  }
}
