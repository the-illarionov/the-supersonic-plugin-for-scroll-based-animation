import { toFixed } from './utils'

import { Animation } from './Animation'

import type { BorderConstructor, BorderUpdateLimits, CalculateProgress, Constructor, HelperConstructor, HelperUpdateLimits, Hooks, Render, UpdateLimits } from './Driver.types'

/**
 * The main purpose of Driver is to calculate current progress from 0 to 1 depending on current scroll
 */
export class Driver {
  id: string
  /** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 3 numbers after decimal point precision */
  progress = 0
  /** Only active drivers are rendered. Driver becomes active when it's HTML elements become visible. You can use this property in your hooks */
  active = false
  /** You can store your custom data here to use between hooks */
  data = {}
  /** Start is linked to [data-supersonic-type="start"] HTML element */
  start: Border
  /** End is linked to [data-supersonic-type="end"] HTML element */
  end: Border

  animations: Map<string, Animation> = new Map()

  helper: Helper

  hooks: Hooks

  constructor({ id, start, end, elements = [], hooks = {} }: Constructor) {
    this.id = id
    this.hooks = hooks

    if (this.hooks.onBeforeInit)
      this.hooks.onBeforeInit(this)

    // Initializing borders
    this.start = new Border({
      domElement: start,
      type: 'start',
      driver: this,
    })
    this.end = new Border({
      domElement: end,
      type: 'end',
      driver: this,
    })

    this.helper = new Helper({ driver: this })

    // Initializing animations
    elements.forEach((selector) => {
      const actualSelector = typeof selector === 'string' ? selector : selector.selector
      const domElements = document.querySelectorAll<HTMLElement>(actualSelector)

      if (domElements.length === 0)
        throw new Error(`Can't find element "${actualSelector}"`)

      domElements.forEach((domElement, domElementIndex) => {
        const animations = domElement.getAnimations() as unknown as CSSAnimation[]

        let actualAnimations: CSSAnimation[] = []

        if (typeof selector === 'string') {
          actualAnimations = animations

          if (actualAnimations.length === 0)
            console.warn(`Element "${actualSelector}" hasn't animations`)
        }
        else if (typeof selector === 'object') {
          if (!selector.animations || selector.animations.length === 0)
            throw new Error(`Can't find animations at element "${actualSelector}"`)

          selector.animations.forEach((animationName) => {
            const cssAnimation = animations.find(animation => animation.animationName === animationName)

            if (cssAnimation)
              actualAnimations.push(cssAnimation)
            else console.warn(`Element "${actualSelector}" hasn't animation: "${animationName}"`)
          })
        }

        actualAnimations.forEach((cssAnimation) => {
          const id = `${actualSelector}---${domElementIndex}---${cssAnimation.animationName}`
          const animation = new Animation({
            id,
            animation: cssAnimation,
          })

          this.animations.set(id, animation)
        })
      })
    })

    if (this.hooks.onAfterInit)
      this.hooks.onAfterInit(this)
  }

  /** Driver calculates its progress and then renders all of it's properties with progress value */
  render({ scroll, renderedInitially, consoleColor }: Render) {
    const oldProgress = this.progress
    this.progress = this.calculateProgress({
      scroll,
      start: this.start.top,
      end: this.end.top,
    })

    if (this.hooks.onBeforeRender)
      this.hooks.onBeforeRender(this)

    if (oldProgress !== this.progress || !renderedInitially) {
      console.groupCollapsed(
          `%cDriver "${this.id}" starts rendering, progress is ${this.progress}, scroll is ${scroll}`,
          `color: ${consoleColor}`,
      )

      for (const animation of this.animations.values()) {
        console.log(`Animation "${animation.id}" starts rendering`)
        animation.render({ driverProgress: this.progress })
        console.log(`Animation "${animation.id}" finished rendering`)
      }

      console.log(`Driver "${this.id}" finished rendering`)
      console.groupEnd()
    }
  }

  /** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
  calculateProgress({ scroll, start, end }: CalculateProgress): number {
    let progress = (scroll - start) / (end - start)
    if (progress < 0)
      progress = 0
    else if (progress > 1)
      progress = 1
    else progress = toFixed(progress, 3)

    return progress
  }

  /** Recalculates DOM elements top offset */
  updateLimits({ scroll, screenHeight }: UpdateLimits) {
    this.start.updateLimits({ scroll })
    this.end.updateLimits({ scroll })
    this.helper.updateLimits({ screenHeight })

    // updateLimits at animations

    if (this.hooks.onUpdateLimits)
      this.hooks.onUpdateLimits(this)
  }

  /** Activates driver when it becomes visible on the screen */
  activate() {
    this.active = true

    if (this.hooks.onActivation)
      this.hooks.onActivation(this)

    console.log(`Driver "${this.id}" activated`)
  }

  /** Deactivates driver when it's progress becomes 0 or 1' */
  deactivate() {
    this.active = false

    if (this.hooks.onDeactivation)
      this.hooks.onDeactivation(this)

    console.log(`Driver "${this.id}" deactivated`)
  }
}

/** An HTML Element. It's top offset serves as indicator of where driver starts and where it ends */
class Border {
  /** Associated DOM element */
  domElement: HTMLElement
  /** Top means amount of scroll needed to border activate or deactivate driver */
  top: number = 0

  constructor({ domElement, type, driver }: BorderConstructor) {
    if (!domElement)
      throw new Error(`Can't find "${type}" HTMLElement for driver "${driver.id}"`)

    this.domElement = domElement
  }

  /** Recalculates top offset */
  updateLimits({ scroll }: BorderUpdateLimits) {
    this.top = ~~this.domElement.getBoundingClientRect().top + scroll
  }
}

/** A helper HTML element, which connects to Border instances and starts being tracked by IntersectionObserver */
class Helper {
  /** DOM element which is dynamically generated by plugin */
  domElement: HTMLElement
  /** Link to corresponding driver */
  driver: Driver

  constructor({ driver }: HelperConstructor) {
    this.driver = driver

    this.domElement = document.createElement('i')
    this.domElement.style.position = 'absolute'
    this.domElement.style.left = '0'
    this.domElement.style.width = '1px'

    this.domElement.setAttribute('data-supersonic-driver', driver.id)
    this.domElement.setAttribute('data-supersonic-type', 'helper')
    this.domElement.classList.add('supersonic-helper')

    document.body.appendChild(this.domElement)

    /*
    this.domElement.style.left =
        Array.from(document.querySelectorAll("[data-supersonic-type='helper']")).indexOf(this.domElement) * 5 +
        "px"
    */
  }

  /** Recalculates position of helper */
  updateLimits({ screenHeight }: HelperUpdateLimits) {
    const top = this.driver.start.top + screenHeight
    const end = this.driver.end.top + screenHeight

    this.domElement.style.setProperty('top', `${top}px`)
    this.domElement.style.setProperty('height', `${end - top}px`)
  }

  /** Deletes helper DOM element */
  uninit() {
    this.domElement.remove()
  }
}
