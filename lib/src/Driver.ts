import { toFixed } from './utils'

import { Animation } from './Animation'
import type { Hooks as AnimationHooks } from './Animation.types'

import type { TheSupersonicPlugin } from './TheSupersonicPlugin'

import type { BorderConstructor, BorderUpdateLimits, CalculateProgress, Constructor, HelperConstructor, HelperUpdateLimits, Hooks, Render, UpdateLimits } from './Driver.types'

const debugColors = {
  colors: ['red', 'blue', 'orange', 'yellow'],
  colorIndex: 0,
}

/**
 * The main purpose of Driver is to calculate current progress from 0 to 1 depending on current scroll and position of 'start' and 'end' elements
 */
export class Driver {
  id: string
  /** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 4 numbers after decimal point precision */
  progress = 0
  /** You can store your custom data here to use between hooks */
  data: any = {}
  /** Start is HTML element. When it appears on the screen, driver will start an animation */
  start: Border
  /** End is HTML element. When it appears on the screen, driver will stop an animation */
  end: Border
  /** Link to plugin instance to be able to access global variables like 'scroll', 'screenHeight' */
  plugin: TheSupersonicPlugin

  animations: Map<string, Animation> = new Map()

  domElements: HTMLElement[] = []

  /** Helper is an element which need for IntersectionObserver to activate or deactive driver */
  helper: Helper

  hooks: Hooks

  constructor({ id, start, end, plugin, elements = [], hooks = {} }: Constructor) {
    this.id = id
    this.plugin = plugin
    this.hooks = hooks

    if (this.hooks.onBeforeInit)
      this.hooks.onBeforeInit({ driver: this })

    // Initializing borders
    this.start = new Border({
      domElement: start,
      type: 'start',
      driver: this,
    })
    this.end = new Border({
      domElement: end,
      type: 'end',
      driver: this,
    })

    this.helper = new Helper({
      id,
      pluginId: this.plugin.id,
      debug: plugin.debug,
    })

    // Initializing animations
    elements.forEach((selector) => {
      const actualSelector = typeof selector === 'string' ? selector : selector.selector
      this.domElements = Array.from(document.querySelectorAll<HTMLElement>(actualSelector))

      if (this.domElements.length === 0)
        throw new Error(`Can't find element "${actualSelector}"`)

      this.domElements.forEach((domElement, domElementIndex) => {
        const elementCssAnimations = domElement.getAnimations() as unknown as CSSAnimation[]

        const animationConfigurations: {
          cssAnimation: CSSAnimation
          hooks: AnimationHooks
        }[] = []

        if (typeof selector === 'string') {
          if (elementCssAnimations.length === 0)
            console.warn(`Element "${actualSelector}" hasn't animations`)

          elementCssAnimations.forEach((cssAnimation) => {
            animationConfigurations.push({
              cssAnimation,
              hooks: {},
            })
          })
        }
        else if (typeof selector === 'object') {
          selector.animations.forEach((animationConfiguration) => {
            let animationName = ''
            let hooks: AnimationHooks = {}

            if (typeof animationConfiguration === 'string') {
              animationName = animationConfiguration
            }
            else if (typeof animationConfiguration === 'object') {
              animationName = animationConfiguration.name
              hooks = animationConfiguration.hooks
            }

            const cssAnimation = elementCssAnimations.find(animation => animation.animationName === animationName)

            if (cssAnimation) {
              animationConfigurations.push({
                cssAnimation,
                hooks,
              })
            }
            else {
              console.warn(`Element "${actualSelector}" hasn't animation: "${animationName}"`)
            }
          })
        }

        animationConfigurations.forEach((animationConfiguration) => {
          const id = `${this.id}---${actualSelector}---${domElementIndex}---${animationConfiguration.cssAnimation.animationName}`
          const animation = new Animation({
            id,
            driver: this,
            cssAnimation: animationConfiguration.cssAnimation,
            hooks: animationConfiguration.hooks,
            domElement,
          })

          this.animations.set(id, animation)
        })
      })
    })

    if (this.hooks.onAfterInit)
      this.hooks.onAfterInit({ driver: this })
  }

  /** Driver calculates its progress and then renders all of it's properties with progress value */
  render({ scroll, renderedInitially, consoleColor = '#000000' }: Render) {
    const oldProgress = this.progress
    this.progress = this.calculateProgress({
      scroll,
      start: this.start.top,
      end: this.end.top,
    })

    if (this.hooks.onBeforeRender) {
      const onBeforeRenderReturn = this.hooks.onBeforeRender({ driver: this })

      if (typeof onBeforeRenderReturn === 'boolean' && !onBeforeRenderReturn)
        return false
    }

    if (oldProgress !== this.progress || !renderedInitially) {
      console.groupCollapsed(
          `%cDriver "${this.id}" starts rendering, progress is ${this.progress}, scroll is ${scroll}`,
          `color: ${consoleColor}`,
      )

      for (const animation of this.animations.values()) {
        console.log(`Animation "${animation.id}" starts rendering`)
        animation.render({ driverProgress: this.progress })
        console.log(`Animation "${animation.id}" finished rendering, currentTime: ${animation.cssAnimation.currentTime}`)
      }

      if (this.hooks.onAfterRender)
        this.hooks.onAfterRender({ driver: this })

      console.log(`Driver "${this.id}" finished rendering`)
      console.groupEnd()
    }
  }

  /** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
  calculateProgress({ scroll, start, end }: CalculateProgress): number {
    let progress = (scroll - start) / (end - start)
    if (progress < 0)
      progress = 0
    else if (progress > 1)
      progress = 1
    else progress = toFixed(progress, 4)

    return progress
  }

  /** Recalculates DOM elements top offset */
  updateLimits({ scroll, screenHeight }: UpdateLimits) {
    this.start.updateLimits({ scroll, screenHeight })
    this.end.updateLimits({ scroll, screenHeight })

    const top = this.start.top + screenHeight
    const bottom = this.end.top - this.start.top
    this.helper.updateLimits({
      top,
      height: bottom - top,
    })

    if (this.hooks.onUpdateLimits)
      this.hooks.onUpdateLimits({ driver: this })
  }

  /** Activates driver when it becomes visible on the screen */
  activate() {
    this.plugin.driverActiveInstances.add(this)

    if (this.hooks.onActivation)
      this.hooks.onActivation({ driver: this })

    console.log(`Driver "${this.id}" activated`)
  }

  /** Deactivates driver when it's progress becomes 0 or 1' */
  deactivate() {
    this.plugin.driverActiveInstances.delete(this)

    if (this.hooks.onDeactivation)
      this.hooks.onDeactivation({ driver: this })

    console.log(`Driver "${this.id}" deactivated`)
  }
}

/** An HTML Element. It's top offset serves as indicator of where driver starts and where it ends */
class Border {
  /** Associated DOM element */
  domElement: HTMLElement
  /** Top means amount of scroll needed to border activate or deactivate driver */
  top: number = 0

  constructor({ domElement, type, driver }: BorderConstructor) {
    if (!domElement)
      throw new Error(`Can't find "${type}" HTMLElement for driver "${driver.id}"`)

    this.domElement = domElement
  }

  /** Recalculates top offset */
  updateLimits({ scroll, screenHeight }: BorderUpdateLimits) {
    this.top = ~~this.domElement.getBoundingClientRect().top + scroll - screenHeight
  }
}

/** A helper HTML element, which connects to Border instances and starts being tracked by IntersectionObserver */
class Helper {
  /** DOM element which is dynamically generated by plugin */
  domElement: HTMLElement

  pluginId: string

  debug: boolean

  constructor({ id, pluginId, debug = false }: HelperConstructor) {
    this.pluginId = pluginId
    this.debug = debug
    this.domElement = document.createElement('i')
    this.domElement.style.position = 'absolute'
    this.domElement.style.left = '0'
    this.domElement.style.width = '1px'

    this.domElement.setAttribute('data-supersonic-driver', id)
    this.domElement.setAttribute('data-supersonic-type', 'helper')
    this.domElement.setAttribute('data-supersonic-plugin-id', this.pluginId)
    this.domElement.classList.add('supersonic-helper')

    document.body.appendChild(this.domElement)

    if (debug) {
      const elements = Array.from(document.querySelectorAll('[data-supersonic-type=\'helper\']'))
      const index = elements.indexOf(this.domElement)
      this.domElement.style.left
        = `${index * 10}px`
      this.domElement.style.width = '10px'
      this.domElement.style.minHeight = '50px'
      this.domElement.style.background = debugColors.colors[debugColors.colorIndex]
      this.domElement.style.zIndex = (100000).toString()
      if (debugColors.colorIndex === 3)
        debugColors.colorIndex = 0
      else debugColors.colorIndex++
      this.domElement.style.opacity = '0.75'
    }
  }

  /** Sets position of helper */
  updateLimits({ top, height }: HelperUpdateLimits) {
    if (height <= 0)
      height = 1
    this.domElement.style.setProperty('top', `${top}px`)
    this.domElement.style.setProperty('height', `${height}px`)
  }

  /** Deletes helper DOM element */
  uninit() {
    this.domElement.remove()
  }
}
