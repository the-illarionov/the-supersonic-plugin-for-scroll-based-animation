import { Element } from './Element';
import { Property } from './Property';

/**
 * The main purpose of Driver is to calculate current progress from 0 to 1 depending on current scroll. Each driver has 2 HTML elements with [data-supersonic-driver="${driverName}"] and [data-supersonic-type="start | "end"]
 */
export declare class Driver {
    /** Driver name, which you use in [data-supersonic-driver] attribute. Can be any value */
    id: string;
    /** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 3 numbers after decimal point precision */
    progress: number;
    /** Only active drivers are rendered. Driver becomes active when it's HTML elements become visible */
    active: boolean;
    /** Initial distance is used to implement all of the transformations after page reload with scroll */
    initialDistanceToScroll: number;
    /** You can store your custom data here to use between hooks */
    data: {};
    /** Start is linked to [data-supersonic-type="start"] HTML element */
    start: DriverBorder;
    /** End is linked to [data-supersonic-type="end"] HTML element */
    end: DriverBorder;
    /** Properties which are animated by this Driver. Properties are added during creating Property instance */
    properties: Set<Property>;
    /** Elements which are animated by this Driver. Elements are added during creating Element instance */
    elements: Set<Element>;
    /** Helper is an HTML element, which is created dynamically and has a height of distance between driver.end and driver.start. IntersectionObserver uses helper to check if driver is active or not. */
    helper: DriverHelper;
    /** Driver hooks */
    hooks: DriverHooks;
    constructor({ id, hooks }: DriverConstructor);
    /** Initialize DOM elements with [data-supersonic-driver] and [data-supersonic-type] */
    initBorders(): void;
    /** Driver calculates its progress and then renders all of it's properties with progress value. Also, driver ensures that only active elements will be rendered */
    render(): void;
    /** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
    calculateProgress(): number;
    /** Recalculates DOM elements top offset */
    updateLimits(): void;
    /** Activates driver when it becomes visible on the screen */
    activate(): void;
    /** Deactivates driver when it's progress becomes 0 or 1' */
    deactivate(): void;
    /** All Driver instances */
    static instances: Map<string, Driver>;
    /** All active Driver instances */
    static activeInstances: Set<Driver>;
    /** Initialize Driver instances */
    static init({ drivers }: MainConfiguration): void;
    /** Unitialize Driver instances */
    static uninit(): void;
    /** Render all of the Driver instances (active or not, depending on argument "useActiveDrivers") */
    static render({ useActiveDrivers }: MainRender): void;
    /** Call "updateLimits()" on each Driver instance, even deactivated */
    static updateLimits(): void;
}
/** One instance for each [data-supersonic-type="start"] and  [data-supersonic-type="end"] */
export declare class DriverBorder {
    /** Associated DOM element */
    domElement: HTMLElement;
    /** Top means amount of scroll needed to border activate or deactivate driver */
    top: number;
    /**
     * this.edge = "bottom" means that scroll amount will be calculated by bottom edge of the screen. In other words, driver will be activated as soon as it becomes visible.
     * this.edge = "top" means that driver will be activated when driver will touch top edge of the screen */
    edge: string;
    constructor({ domElement, selector }: DriverBorderConstructor);
    /** Recalculates top offset */
    updateLimits(): void;
}
/** A helper HTML element, which connects to DriverBorder instances and starts being tracked by IntersectionObserver */
export declare class DriverHelper {
    /** DOM element which is dynamically generated by plugin */
    domElement: HTMLElement;
    /** Link to corresponding driver */
    driver: Driver;
    constructor({ driver }: {
        driver: Driver;
    });
    /** Recalculates position of helper */
    updateLimits(): void;
    /** Deletes helper DOM elements */
    uninit(): void;
    /** Styles, applied to helper */
    static styles: {
        position: string;
        left: number;
        width: string;
    };
}
