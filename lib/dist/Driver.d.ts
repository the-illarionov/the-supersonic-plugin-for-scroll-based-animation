import { BorderConstructor, BorderUpdateLimits, CalculateProgress, Constructor, HelperConstructor, HelperUpdateLimits, Hooks, Render, UpdateLimits } from './Driver.types';
import { Animation } from './Animation';

/**
 * The main purpose of Driver is to calculate current progress from 0 to 1 depending on current scroll
 */
export declare class Driver {
    id: string;
    /** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 4 numbers after decimal point precision */
    progress: number;
    /** You can store your custom data here to use between hooks */
    data: any;
    /** Start is linked to [data-supersonic-type="start"] HTML element */
    start: Border;
    /** End is linked to [data-supersonic-type="end"] HTML element */
    end: Border;
    pluginId: string;
    animations: Map<string, Animation>;
    domElements: HTMLElement[];
    helper: Helper;
    hooks: Hooks;
    constructor({ id, start, end, pluginId, elements, hooks }: Constructor);
    /** Driver calculates its progress and then renders all of it's properties with progress value */
    render({ scroll, renderedInitially, consoleColor }: Render): false | undefined;
    /** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
    calculateProgress({ scroll, start, end }: CalculateProgress): number;
    /** Recalculates DOM elements top offset */
    updateLimits({ scroll, screenHeight }: UpdateLimits): void;
    /** Activates driver when it becomes visible on the screen */
    activate(): void;
    /** Deactivates driver when it's progress becomes 0 or 1' */
    deactivate(): void;
}
/** An HTML Element. It's top offset serves as indicator of where driver starts and where it ends */
declare class Border {
    /** Associated DOM element */
    domElement: HTMLElement;
    /** Top means amount of scroll needed to border activate or deactivate driver */
    top: number;
    constructor({ domElement, type, driver }: BorderConstructor);
    /** Recalculates top offset */
    updateLimits({ scroll, screenHeight }: BorderUpdateLimits): void;
}
/** A helper HTML element, which connects to Border instances and starts being tracked by IntersectionObserver */
declare class Helper {
    /** DOM element which is dynamically generated by plugin */
    domElement: HTMLElement;
    pluginId: string;
    constructor({ id, pluginId }: HelperConstructor);
    /** Recalculates position of helper */
    updateLimits({ top, bottom, screenHeight }: HelperUpdateLimits): void;
    /** Deletes helper DOM element */
    uninit(): void;
}
export {};
