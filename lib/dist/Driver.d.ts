import { BorderConstructor, BorderUpdateLimits, CalculateProgress, Constructor, HelperConstructor, HelperUpdateLimits, Hooks, Render, UpdateLimits } from './Driver.types';
import { TheSupersonicPlugin } from './TheSupersonicPlugin';
import { Animation } from './Animation';

/**
 * The main purpose of Driver is to calculate current progress from 0 to 1 depending on current scroll and position of 'start' and 'end' elements
 */
export declare class Driver {
    id: string;
    /** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 4 numbers after decimal point precision */
    progress: number;
    /** You can store your custom data here to use between hooks */
    data: any;
    /** Start is HTML element. When it appears on the screen, driver will start an animation */
    start: Border;
    /** End is HTML element. When it appears on the screen, driver will stop an animation */
    end: Border;
    /** Link to plugin instance to be able to access global variables like 'scroll', 'screenHeight' */
    plugin: TheSupersonicPlugin;
    animations: Map<string, Animation>;
    domElements: HTMLElement[];
    /** Helper is an element which need for IntersectionObserver to activate or deactive driver */
    helper: Helper;
    hooks: Hooks;
    constructor({ id, start, end, plugin, elements, hooks }: Constructor);
    /** Driver calculates its progress and then renders all of it's properties with progress value */
    render({ scroll, renderedInitially, consoleColor }: Render): false | undefined;
    /** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
    calculateProgress({ scroll, start, end }: CalculateProgress): number;
    /** Recalculates DOM elements top offset */
    updateLimits({ scroll, screenHeight }: UpdateLimits): void;
    /** Activates driver when it becomes visible on the screen */
    activate(): void;
    /** Deactivates driver when it's progress becomes 0 or 1' */
    deactivate(): void;
}
/** An HTML Element. It's top offset serves as indicator of where driver starts and where it ends */
declare class Border {
    /** Associated DOM element */
    domElement: HTMLElement;
    /** Top means amount of scroll needed to border activate or deactivate driver */
    top: number;
    constructor({ domElement, type, driver }: BorderConstructor);
    /** Recalculates top offset */
    updateLimits({ scroll, screenHeight }: BorderUpdateLimits): void;
}
/** A helper HTML element, which connects to Border instances and starts being tracked by IntersectionObserver */
declare class Helper {
    /** DOM element which is dynamically generated by plugin */
    domElement: HTMLElement;
    pluginId: string;
    debug: boolean;
    constructor({ id, pluginId, debug }: HelperConstructor);
    /** Sets position of helper */
    updateLimits({ top, height }: HelperUpdateLimits): void;
    /** Deletes helper DOM element */
    uninit(): void;
}
export {};
