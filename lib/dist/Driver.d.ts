import { BorderConstructor, Constructor, HelperConstructor, Hooks, Init, Render } from './Driver.types';
import { Element } from './Element';
import { TheSuperSonicPlugin } from './TheSupersonicPlugin';
import { Property } from './Property';

/**
 * The main purpose of Driver is to calculate current progress from 0 to 1 depending on current scroll
 */
export declare class Driver {
    id: string;
    /** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 3 numbers after decimal point precision */
    progress: number;
    /** Only active drivers are rendered. Driver becomes active when it's HTML elements become visible */
    active: boolean;
    /** Initial distance is used to implement all of the transformations after page reload with scroll */
    initialDistanceToScroll: number;
    /** You can store your custom data here to use between hooks */
    data: {};
    /** Start is linked to [data-supersonic-type="start"] HTML element */
    start: Border;
    /** End is linked to [data-supersonic-type="end"] HTML element */
    end: Border;
    /** Properties which are animated by this Driver. Properties are added during creating Property instance */
    properties: Set<Property>;
    /** Elements which are animated by this Driver. Elements are added during creating Element instance */
    elements: Set<Element>;
    /** Helper is an HTML element, which is created dynamically and has a height of distance between driver.end and driver.start. IntersectionObserver uses helper to check if driver is active or not. */
    helper: Helper;
    plugin: TheSuperSonicPlugin;
    hooks: Hooks;
    constructor({ id, plugin, start, end, hooks }: Constructor);
    /** Driver calculates its progress and then renders all of it's properties with progress value. Also, driver ensures that only active elements will be rendered */
    render(): void;
    /** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
    calculateProgress(): number;
    /** Recalculates DOM elements top offset */
    updateLimits(): void;
    /** Activates driver when it becomes visible on the screen */
    activate(): void;
    /** Deactivates driver when it's progress becomes 0 or 1' */
    deactivate(): void;
    /** All Driver instances */
    static instances: Map<string, Driver>;
    /** All active Driver instances */
    static activeInstances: Set<Driver>;
    /** Initialize Driver instances */
    static init({ drivers, plugin }: Init): void;
    /** Unitialize Driver instances */
    static uninit(): void;
    /** Render all of the Driver instances (active or not, depending on argument "useActiveDrivers") */
    static render({ useActiveDrivers, plugin }: Render): void;
    /** Call "updateLimits()" on each Driver instance, even deactivated */
    static updateLimits(): void;
}
/** One instance for each [data-supersonic-type="start"] and  [data-supersonic-type="end"] */
declare class Border {
    /** Associated DOM element */
    domElement: HTMLElement;
    /** Top means amount of scroll needed to border activate or deactivate driver */
    top: number;
    plugin: TheSuperSonicPlugin;
    constructor({ domElement, plugin, type, driver }: BorderConstructor);
    /** Recalculates top offset */
    updateLimits(): void;
}
/** A helper HTML element, which connects to Border instances and starts being tracked by IntersectionObserver */
declare class Helper {
    /** DOM element which is dynamically generated by plugin */
    domElement: HTMLElement;
    /** Link to corresponding driver */
    driver: Driver;
    plugin: TheSuperSonicPlugin;
    constructor({ driver, plugin }: HelperConstructor);
    /** Recalculates position of helper */
    updateLimits(): void;
    /** Deletes helper DOM element */
    uninit(): void;
}
export {};
