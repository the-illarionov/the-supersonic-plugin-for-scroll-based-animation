var g = Object.defineProperty;
var R = (r, e, t) => e in r ? g(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var s = (r, e, t) => (R(r, typeof e != "symbol" ? e + "" : e, t), t);
function w(r, e) {
  return e = 10 ** e, ~~(r * e) / e;
}
function x(r, e) {
  let t;
  return function() {
    clearTimeout(t), t = setTimeout(() => r.apply(this), e);
  };
}
function I() {
  return Math.random().toString(16).substring(2);
}
class B {
  constructor({ id: e, cssAnimation: t, hooks: i, driver: o, domElement: h }) {
    s(this, "id");
    s(this, "cssAnimation");
    /** You can store your custom data here to use between hooks */
    s(this, "data", {});
    /** Reference to linked `Driver` instance */
    s(this, "driver");
    /** You can access domElement this animation is belongs to */
    s(this, "domElement");
    s(this, "hooks");
    this.id = e, this.driver = o, this.cssAnimation = t, this.hooks = i, this.domElement = h, this.hooks.onInit && this.hooks.onInit(this);
  }
  render({ driverProgress: e }) {
    let t = e * 1e4;
    if (this.hooks.onBeforeRender) {
      const i = this.hooks.onBeforeRender(this);
      if (typeof i == "number")
        t = i;
      else if (typeof i == "boolean" && !i)
        return !1;
    }
    this.cssAnimation.currentTime = t, this.hooks.onAfterRender && this.hooks.onAfterRender(this);
  }
}
const m = {
  colors: ["red", "blue", "orange", "yellow"],
  colorIndex: 0
};
class L {
  constructor({ id: e, start: t, end: i, plugin: o, elements: h = [], hooks: l = {} }) {
    s(this, "id");
    /** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 4 numbers after decimal point precision */
    s(this, "progress", 0);
    /** You can store your custom data here to use between hooks */
    s(this, "data", {});
    /** Start is HTML element. When it appears on the screen, driver will start an animation */
    s(this, "start");
    /** End is HTML element. When it appears on the screen, driver will stop an animation */
    s(this, "end");
    /** Link to plugin instance to be able to access global variables like 'scroll', 'screenHeight' */
    s(this, "plugin");
    s(this, "animations", /* @__PURE__ */ new Map());
    /** Helper is an element which need for IntersectionObserver to activate or deactive driver */
    s(this, "helper");
    s(this, "hooks");
    this.id = e, this.plugin = o, this.hooks = l, this.hooks.onBeforeInit && this.hooks.onBeforeInit(this), this.start = new A({
      domElement: t,
      type: "start",
      driver: this
    }), this.end = new A({
      domElement: i,
      type: "end",
      driver: this
    }), this.helper = new S({
      id: e,
      pluginId: this.plugin.id,
      debug: o.debug
    }), h.forEach((n) => {
      const a = typeof n == "string" ? n : n.selector, p = Array.from(document.querySelectorAll(a));
      if (p.length === 0)
        throw new Error(`Can't find element "${a}"`);
      p.forEach((k, E) => {
        const u = k.getAnimations(), v = [];
        typeof n == "string" ? (u.length, u.forEach((d) => {
          v.push({
            cssAnimation: d,
            hooks: {}
          });
        })) : typeof n == "object" && n.animations.forEach((d) => {
          let c = "", f = {};
          typeof d == "string" ? c = d : typeof d == "object" && (c = d.name, f = d.hooks);
          const y = u.find((b) => b.animationName === c);
          y && v.push({
            cssAnimation: y,
            hooks: f
          });
        }), v.forEach((d) => {
          const c = `${this.id}---${a}---${E}---${d.cssAnimation.animationName}`, f = new B({
            id: c,
            driver: this,
            cssAnimation: d.cssAnimation,
            hooks: d.hooks,
            domElement: k
          });
          this.animations.set(c, f);
        });
      });
    }), this.hooks.onAfterInit && this.hooks.onAfterInit(this);
  }
  /** Driver calculates its progress and then renders all of it's properties with progress value */
  render({ scroll: e, renderedInitially: t, consoleColor: i = "#000000" }) {
    const o = this.progress;
    if (this.progress = this.calculateProgress({
      scroll: e,
      start: this.start.top,
      end: this.end.top
    }), this.hooks.onBeforeRender) {
      const h = this.hooks.onBeforeRender(this);
      if (typeof h == "boolean" && !h)
        return !1;
    }
    if (o !== this.progress || !t) {
      for (const h of this.animations.values())
        h.render({ driverProgress: this.progress });
      this.hooks.onAfterRender && this.hooks.onAfterRender(this);
    }
  }
  /** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
  calculateProgress({ scroll: e, start: t, end: i }) {
    let o = (e - t) / (i - t);
    return o < 0 ? o = 0 : o > 1 ? o = 1 : o = w(o, 4), o;
  }
  /** Recalculates DOM elements top offset */
  updateLimits({ scroll: e, screenHeight: t }) {
    this.start.updateLimits({ scroll: e, screenHeight: t }), this.end.updateLimits({ scroll: e, screenHeight: t });
    const i = this.start.top + t;
    this.helper.updateLimits({
      top: i,
      height: this.end.top - i
    }), this.hooks.onUpdateLimits && this.hooks.onUpdateLimits(this);
  }
  /** Activates driver when it becomes visible on the screen */
  activate() {
    this.plugin.driverActiveInstances.add(this), this.hooks.onActivation && this.hooks.onActivation(this);
  }
  /** Deactivates driver when it's progress becomes 0 or 1' */
  deactivate() {
    this.plugin.driverActiveInstances.delete(this), this.hooks.onDeactivation && this.hooks.onDeactivation(this);
  }
}
class A {
  constructor({ domElement: e, type: t, driver: i }) {
    /** Associated DOM element */
    s(this, "domElement");
    /** Top means amount of scroll needed to border activate or deactivate driver */
    s(this, "top", 0);
    if (typeof e == "string" && (e = document.querySelector(e)), !e)
      throw new Error(`Can't find "${t}" HTMLElement for driver "${i.id}"`);
    this.domElement = e;
  }
  /** Recalculates top offset */
  updateLimits({ scroll: e, screenHeight: t }) {
    this.top = ~~this.domElement.getBoundingClientRect().top + e - t;
  }
}
class S {
  constructor({ id: e, pluginId: t, debug: i = !1 }) {
    /** DOM element which is dynamically generated by plugin */
    s(this, "domElement");
    s(this, "pluginId");
    s(this, "debug");
    if (this.pluginId = t, this.debug = i, this.domElement = document.createElement("i"), this.domElement.style.position = "absolute", this.domElement.style.left = "0", this.domElement.style.width = "1px", this.domElement.setAttribute("data-supersonic-driver", e), this.domElement.setAttribute("data-supersonic-type", "helper"), this.domElement.setAttribute("data-supersonic-plugin-id", this.pluginId), this.domElement.classList.add("supersonic-helper"), document.body.appendChild(this.domElement), i) {
      const h = Array.from(document.querySelectorAll("[data-supersonic-type='helper']")).indexOf(this.domElement);
      this.domElement.style.left = `${h * 10}px`, this.domElement.style.width = "10px", this.domElement.style.minHeight = "50px", this.domElement.style.background = m.colors[m.colorIndex], this.domElement.style.zIndex = "100000", m.colorIndex === 3 ? m.colorIndex = 0 : m.colorIndex++, this.domElement.style.opacity = "0.75";
    }
  }
  /** Sets position of helper */
  updateLimits({ top: e, height: t }) {
    t <= 0 && (t = 1), this.domElement.style.setProperty("top", `${e}px`), this.domElement.style.setProperty("height", `${t}px`);
  }
  /** Deletes helper DOM element */
  uninit() {
    this.domElement.remove();
  }
}
class z {
  constructor({ observables: e, driverInstances: t }) {
    s(this, "instance");
    this.instance = new IntersectionObserver(
      (i) => {
        i.forEach((o) => {
          const l = o.target.dataset.supersonicDriver, n = t.get(l);
          if (!n)
            throw new Error(`Observer can't find driver "${l}"`);
          o.isIntersecting ? n.activate() : n.deactivate();
        });
      }
    ), e.forEach((i) => {
      this.instance.observe(i);
    });
  }
  uninit() {
    this.instance.disconnect();
  }
}
class D {
  constructor(e, t) {
    /** Unique id of this running instance. You explicitly define it or let plugin auto generate it */
    s(this, "id");
    /** Current window scrollY */
    s(this, "scroll", 0);
    /** Current screen height */
    s(this, "screenHeight", 0);
    /** Required to get all of the drivers render at once to stand on their first frame */
    s(this, "renderedInitially", !1);
    /** Used to cancelAnimationFrame on 'uninit()' */
    s(this, "rafId", 0);
    /** Color of console messages in dev mode. It changes each frame to make it more convenient to visually separate frames */
    s(this, "consoleColor", "#ffffff");
    /** IntersectionObserver instance */
    s(this, "observer", null);
    /** Debounced resize listener */
    s(this, "onResize", null);
    /** You can store your custom data here to use between hooks */
    s(this, "data", {});
    /** Make helper visible */
    s(this, "debug");
    s(this, "hooks", {});
    s(this, "driverInstances", /* @__PURE__ */ new Map());
    s(this, "driverActiveInstances", /* @__PURE__ */ new Set());
    var h, l;
    this.id = (t == null ? void 0 : t.id) ?? I(), this.hooks = (t == null ? void 0 : t.hooks) ?? {}, this.debug = (t == null ? void 0 : t.debug) ?? !1, (h = this.hooks) != null && h.onBeforeInit && this.hooks.onBeforeInit(this), e.forEach((n) => {
      const a = n.id ?? I(), p = new L({
        id: a,
        hooks: n.hooks,
        start: n.start,
        end: n.end,
        elements: n.elements,
        plugin: this
      });
      this.driverInstances.set(a, p);
    }), this.updateLimits();
    const i = Array.from(document.querySelectorAll(`[data-supersonic-type="helper"][data-supersonic-plugin-id="${this.id}"]`));
    this.observer = new z({
      observables: i,
      driverInstances: this.driverInstances
    });
    const o = () => {
      var n;
      (n = this.hooks) != null && n.onBeforeResize && this.hooks.onBeforeResize(this), this.updateLimits(), this.render({ useActiveDrivers: !1 }), this.hooks.onAfterResize && this.hooks.onAfterResize(this);
    };
    this.onResize = x(o, 250), window.addEventListener("resize", this.onResize), this.render({ useActiveDrivers: !1 }), this.renderedInitially = !0, (l = this.hooks) != null && l.onAfterInit && this.hooks.onAfterInit(this);
  }
  /** Removes all of the plugin stuff (useful for SPA) */
  uninit() {
    for (const e of this.driverInstances.values())
      e.helper.uninit();
    this.driverInstances.clear(), this.driverActiveInstances.clear(), this.observer.uninit(), cancelAnimationFrame(this.rafId), window.removeEventListener("resize", this.onResize);
  }
  /** Main rendering cycle. Active drivers are visible ones */
  render({ useActiveDrivers: e }) {
    if (this.updateScroll(), this.hooks.onBeforeRender) {
      const i = this.hooks.onBeforeRender(this);
      if (typeof i == "boolean" && !i)
        return !1;
    }
    const t = e ? this.driverActiveInstances.values() : this.driverInstances.values();
    for (const i of t)
      i.render({
        scroll: this.scroll,
        renderedInitially: this.renderedInitially,
        consoleColor: this.consoleColor
      });
    this.rafId = requestAnimationFrame(() => {
      this.render({ useActiveDrivers: !0 });
    }), this.hooks.onAfterRender && this.hooks.onAfterRender(this);
  }
  /** Updates global scroll and driver DOM elements top offset. Called once on page load and each time after window.resize */
  updateLimits() {
    this.updateScreenHeight(), this.updateScroll();
    for (const e of this.driverInstances.values())
      e.updateLimits({
        scroll: this.scroll,
        screenHeight: this.screenHeight
      });
  }
  updateScroll() {
    this.scroll = window.scrollY || document.documentElement.scrollTop;
  }
  /** Dirty hack for calculating screen height. We can't just use "window.innerHeight" because it "jumps" on mobile phones when you scroll and toolbar collapses */
  updateScreenHeight() {
    const e = {
      position: "absolute",
      left: "0",
      top: "0",
      height: "100vh",
      width: "1px",
      zIndex: "-1",
      visibility: "hidden"
    }, t = document.createElement("div");
    for (const i in e)
      t.style.setProperty(i, e[i]);
    document.body.appendChild(t), this.screenHeight = t.clientHeight, t.remove();
  }
}
export {
  B as Animation,
  L as Driver,
  D as TheSupersonicPlugin
};
