import { devGlobals, Globals } from "../singletons/Globals"
import { throwError, supersonicToFixed } from "../singletons/Helpers"
import { Property } from "./Property"
import { Element } from "./Element"

/**
 * The main purpose of Driver is to calculate current progress from 0 to 1 depending on current scroll. Each driver has 2 HTML elements with [data-supersonic-driver="${driverName}"] and [data-supersonic-type="start | "end"]
 */
export class Driver {
	/** Driver name, which you use in [data-supersonic-driver] attribute. Can be any value */
	id: string
	/** Progress is generated by script and means how much of the scroll covered right now. Minimum value: 0, maximum value: 1, float number with 3 numbers after decimal point precision */
	progress = 0
	/** Only active drivers are rendered. Driver becomes active when it's HTML elements become visible */
	active = false
	/** Initial distance is used to implement all of the transformations after page reload with scroll */
	initialDistanceToScroll = 0
	/** You can store your custom data here to use between hooks */
	data = {}
	/** Start is linked to [data-supersonic-type="start"] HTML element */
	start!: DriverBorder
	/** End is linked to [data-supersonic-type="end"] HTML element */
	end!: DriverBorder
	/** Properties which are animated by this Driver. Properties are added during creating Property instance */
	properties: Set<Property> = new Set()
	/** Elements which are animated by this Driver. Elements are added during creating Element instance */
	elements: Set<Element> = new Set()
	/** Helper is an HTML element, which is created dynamically and has a height of distance between driver.end and driver.start. IntersectionObserver uses helper to check if driver is active or not. */
	helper: DriverHelper
	/** Driver hooks */
	hooks: DriverHooks

	constructor({ id, hooks }: DriverConstructor) {
		this.id = id
		this.hooks = hooks ?? {}

		this.initBorders()
		this.helper = new DriverHelper({ driver: this })

		Driver.instances.set(id, this)

		if (this.hooks.onInit) this.hooks.onInit(this)
	}

	/** Initialize DOM elements with [data-supersonic-driver] and [data-supersonic-type] */
	initBorders() {
		const driverSelector = `[data-supersonic-driver="${this.id}"]`
		const selectorStart = `${driverSelector}[data-supersonic-type="start"]`
		const selectorEnd = `${driverSelector}[data-supersonic-type="end"]`

		this.start = new DriverBorder({
			domElement: document.querySelector<HTMLElement>(selectorStart)!,
			selector: selectorStart,
		})
		this.end = new DriverBorder({
			domElement: document.querySelector<HTMLElement>(selectorEnd)!,
			selector: selectorEnd,
		})
	}

	/** Driver calculates its progress and then renders all of it's properties with progress value. Also, driver ensures that only active elements will be rendered */
	render() {
		const oldProgress = this.progress
		this.progress = this.calculateProgress()

		if (this.hooks.onBeforeRender) this.hooks.onBeforeRender(this)

		if (oldProgress !== this.progress || !Globals.renderedInitially) {
			if (devGlobals.showConsole) {
				console.log(
					`%cDriver "${this.id}" starts rendering, progress is ${this.progress}, Globals.scroll is ${Globals.scroll}`,
					devGlobals.consoleStyles
				)
			}

			for (let property of this.properties) {
				property.render()
			}
			for (let element of this.elements) {
				Element.activeInstances.add(element)
			}

			if (this.hooks.onAfterRender) this.hooks.onAfterRender(this)

			if (devGlobals.showConsole) {
				console.log(`%c/Driver "${this.id}" finished rendering`, devGlobals.consoleStyles)
			}
		}
	}

	/** Calculates current driver progress, depending on current scroll and top offset of DOM elements */
	calculateProgress(): number {
		let progress = (Globals.scroll - this.start.top) / (this.end.top - this.start.top)
		if (progress < 0) progress = 0
		else if (progress > 1) progress = 1
		else progress = supersonicToFixed(progress, 4)

		return progress
	}

	/** Recalculates DOM elements top offset */
	updateLimits() {
		this.start.updateLimits()
		this.end.updateLimits()
		if (this.end.top < this.start.top) this.end.top += Globals.screenHeight
		this.helper.updateLimits()

		for (let property of this.properties) {
			property.updateLimits()
		}
		for (let element of this.elements) {
			element.updateLimits(this)
		}

		if (this.hooks.onUpdateLimits) this.hooks.onUpdateLimits(this)
	}

	/** Activates driver when it becomes visible on the screen */
	activate() {
		this.active = true
		Driver.activeInstances.add(this)

		if (this.hooks.onActivation) this.hooks.onActivation(this)

		if (devGlobals.showConsole) {
			console.log(`%c------ Driver "${this.id}" activated`, devGlobals.consoleStyles + "font-weight: bold")
		}
	}

	/** Deactivates driver when it's progress becomes 0 or 1' */
	deactivate() {
		this.active = false
		Driver.activeInstances.delete(this)

		if (this.hooks.onDeactivation) this.hooks.onDeactivation(this)

		if (devGlobals.showConsole) {
			console.log(`%c------ Driver "${this.id}" deactivated`, devGlobals.consoleStyles + "font-weight: bold")
		}
	}

	//
	//
	// static properties
	/** All Driver instances */
	static instances: Map<string, Driver> = new Map()
	/** All active Driver instances */
	static activeInstances: Set<Driver> = new Set()

	//
	//
	// static methods
	/** Initialize Driver instances */
	static init({ drivers }: MainConfiguration) {
		for (let id in drivers) {
			new Driver({
				id,
				hooks: drivers[id].hooks!,
			})
		}
	}

	/** Unitialize Driver instances */
	static uninit() {
		for (let driver of Driver.instances.values()) {
			driver.helper.uninit()
		}

		Driver.instances.clear()
	}

	/** Render all of the Driver instances (active or not, depending on argument "useActiveDrivers") */
	static render({ useActiveDrivers }: MainRender) {
		const drivers = useActiveDrivers ? Driver.activeInstances.values() : Driver.instances.values()

		for (let driver of drivers) {
			if (!Globals.renderedInitially) driver.initialDistanceToScroll = driver.end.top - Globals.scroll
			driver.render()
		}
	}

	/** Call "updateLimits()" on each Driver instance, even deactivated */
	static updateLimits() {
		for (let driver of Driver.instances.values()) {
			driver.updateLimits()
		}
	}
}

/** One instance for each [data-supersonic-type="start"] and  [data-supersonic-type="end"] */
export class DriverBorder {
	/** Associated DOM element */
	domElement: HTMLElement
	/** Top means amount of scroll needed to border activate or deactivate driver */
	top: number = 0
	/**
	 * this.edge = "bottom" means that scroll amount will be calculated by bottom edge of the screen. In other words, driver will be activated as soon as it becomes visible.
	 * this.edge = "top" means that driver will be activated when driver will touch top edge of the screen */
	edge = "bottom"

	constructor({ domElement, selector }: DriverBorderConstructor) {
		if (!domElement) {
			throwError(`Can't find DOM element: ${selector}"]`)
		}
		if (domElement.dataset.supersonicEdge === "top") this.edge = "top"
		this.domElement = domElement
	}

	/** Recalculates top offset */
	updateLimits() {
		this.top = this.domElement.getBoundingClientRect().top + Globals.scroll

		if (this.edge === "bottom") this.top -= Globals.screenHeight
	}
}

/** A helper HTML element, which connects to DriverBorder instances and starts being tracked by IntersectionObserver */
export class DriverHelper {
	/** DOM element which is dynamically generated by plugin */
	domElement: HTMLElement
	/** Link to corresponding driver */
	driver: Driver

	constructor({ driver }: { driver: Driver }) {
		this.driver = driver

		this.domElement = document.createElement("i")
		for (let cssProperty in DriverHelper.styles) {
			// @ts-ignore
			this.domElement.style.setProperty(cssProperty, DriverHelper.styles[cssProperty])
		}
		this.domElement.setAttribute("data-supersonic-driver", driver.id)
		this.domElement.setAttribute("data-supersonic-type", "helper")
		this.domElement.classList.add("supersonic-helper")

		document.body.appendChild(this.domElement)

		/* if (!devGlobals.isProduction) {
			this.domElement.style.left =
				Array.from(document.querySelectorAll("[data-supersonic-type='helper']")).indexOf(this.domElement) * 5 +
				"px"
		} */
	}

	/** Recalculates position of helper */
	updateLimits() {
		let top = this.driver.start.top
		let end = this.driver.end.top

		if (this.driver.start.edge === "bottom") top += Globals.screenHeight
		if (this.driver.end.edge === "bottom") end += Globals.screenHeight

		this.domElement.style.setProperty("top", top + "px")
		this.domElement.style.setProperty("height", end - top + "px")
	}

	/** Deletes helper DOM elements */
	uninit() {
		this.domElement.remove()
	}

	/** Styles, applied to helper */
	static styles = {
		position: "absolute",
		left: 0,
		width: "1px",
	}
}
